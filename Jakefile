/**
 * Instructions for updating this file.
 * - this file must be updated everytime a new cross-folder dependency is added
 *   into any of the [refs.ts] file. For instance, if suddenly you add a
 *   reference to [../storage/whatever.ts] in [libwinRT/refs.ts], then you must
 *   update the dependencies of the [libwinRT/refs.d.ts] task.
 **/
var child_process = require("child_process");
var fs = require("fs");

// The local [tsc] compiler.
var tsc = "node node_modules/typescript/bin/tsc";

// The list of files generated by the build.
// XXX put everything in the build/ directory and make the clean task just rmRf
// that directory.
var generated = [];

function mkTscCall(dir, refs, out) {
    return [
        tsc,
        "--noEmitOnError",
        "--target ES5",
        "--module commonjs",
        out ? "--out "+dir+"/"+refs+".js" : "",
        "--declaration "+dir+"/"+refs+".ts"
    ].join(" ");
}

function mkSimpleTask(production, dependencies, folder, target, isStandalone) {
    generated.push(folder+'/'+target+'.js');
    generated.push(folder+'/'+target+'.d.ts');

    return file(production, dependencies, { async: true }, function () {
        console.log("[B] "+production);
        jake.exec(mkTscCall(folder, target, !isStandalone), { printStdout: true }, function () {
            complete();
        });
    });
}

// A series of compile-and-run rules that generate various files for the build
// system. They currently have to run from the [build] directory but this is
// FIXME

function runInBuildAndComplete(cmds) {
    process.chdir("build");
    jake.exec(cmds, {}, function() {
        process.chdir("..");
        complete();
    });
}

mkSimpleTask('genStubs/genmeta.js', [ 'genStubs', ], "genStubs", "genmeta", true);
file('build/api.js', [ "genStubs/genmeta.js" ], { async: true }, function () {
    console.log("[P] generating build/api.js, localization.json and topiclist.json");
    runInBuildAndComplete([
        "node ../genStubs/genmeta.js",
    ]);
});
generated.push('build/api.js');
generated.push('build/localization.json');
generated.push('build/topiclist.json');

mkSimpleTask('cssPrefixes/addCssPrefixes.js', [ 'cssPrefixes' ], "cssPrefixes", "addCssPrefixes");
task('css-prefixes', [ "cssPrefixes/addCssPrefixes.js" ], { async: true }, function () {
    console.log("[P] modifying in-place all css files");
    runInBuildAndComplete([
        "node ../cssPrefixes/addCssPrefixes.js"
    ]);
});

mkSimpleTask('shell/shell.js', [], "shell", "shell", true);
mkSimpleTask('shell/package.js', [ 'shell/shell.js' ], "shell", "package", true);
file('build/pkgshell.js', [ 'shell/package.js' ], { async: true }, function () {
    console.log("[P] generating build/pkgshell.js and packaging");
    runInBuildAndComplete([
        "node ../shell/package.js"
    ]);
});
generated.push('build/pkgshell.js');


// These dependencies have been hand-crafted by reading the various [refs.ts]
// files. The dependencies inside the same folder are coarse-grained: for
// instance, anytime something changes in [editor/], [editor/refs.d.ts] gets
// rebuilt. This amounts to assuming that for all [foo/bar.ts], [bar.ts] appears
// in [foo/refs.ts].
mkSimpleTask('browser/browser.d.ts', [
    'browser/browser.ts'
], "browser", "browser");
mkSimpleTask('rt/refs.d.ts', [
    'browser/browser.d.ts',
    'rt',
    'lib'
], "rt", "refs");
mkSimpleTask('storage/refs.d.ts', [
    'rt/refs.d.ts',
    'rt/typings.d.ts',
    'browser/browser.d.ts',
    'storage'
], "storage", "refs");
mkSimpleTask('ast/refs.d.ts', [
    'rt/refs.d.ts',
    'ast'
], "ast", "refs");
mkSimpleTask('libwinRT/refs.d.ts', [
    'rt/refs.d.ts',
    'browser/browser.d.ts',
    'libwinRT'
], "libwinRT", "refs");
mkSimpleTask('libwab/refs.d.ts', [
    'rt/refs.d.ts',
    'rt/typings.d.ts',
    'browser/browser.d.ts',
    'libwab'
], "libwab", "refs");
mkSimpleTask('libnode/refs.d.ts', [
    'rt/refs.d.ts',
    'rt/typings.d.ts',
    'libnode'
], "libnode", "refs");
mkSimpleTask('libcordova/refs.d.ts', [
    'rt/refs.d.ts',
    'rt/typings.d.ts',
    'browser/browser.d.ts',
    'libcordova'
], "libcordova", "refs");
mkSimpleTask('editor/refs.d.ts', [
    'rt/typings.d.ts',
    'browser/browser.d.ts',
    'rt/refs.d.ts',
    'ast/refs.d.ts',
    'storage/refs.d.ts',
    'libwinRT/refs.d.ts',
    'libwab/refs.d.ts',
    'libcordova/refs.d.ts',
    'intellitrain',
    'editor'
], "editor", "refs");
mkSimpleTask('officemix/officemix.d.ts', [
    'officemix'
], "officemix", "officemix");
mkSimpleTask('noderunner/jsonapi.d.ts', [], "noderunner", "jsonapi"); 
mkSimpleTask('nodeclient/client.d.ts', [
    'rt/typings.d.ts',
    'noderunner/jsonapi.d.ts'
], "nodeclient", "client", true);
// XXX coarse-grained dependencies here over the whole 'noderunner' directory
mkSimpleTask('noderunner/runner.d.ts', [
    'browser/browser.d.ts',
    'rt/typings.d.ts',
    'rt/refs.d.ts', 
    'ast/refs.d.ts',
    'libnode/refs.d.ts',
    'noderunner'
], "noderunner", "runner", true);
// XXX same here
mkSimpleTask('runner/refs.d.ts', [
    'browser/browser.d.ts',
    'rt/typings.d.ts',
    'rt/refs.d.ts', 
    'storage/refs.d.ts',
    'libwinRT/refs.d.ts',
    'libwab/refs.d.ts',
    'libnode/refs.d.ts',
    'libcordova/refs.d.ts',
    'runner'
], "runner", "refs");
// XXX same here
mkSimpleTask('mc/refs.d.ts', [
    'browser/browser.d.ts',
    'rt/typings.d.ts',
    'rt/refs.d.ts', 
    'storage/refs.d.ts',
    'mc'
], "mc", "refs");


// Now come the rules for files that are obtained by concatenating multiple
// _js_ files into another one. [buildDeps] is for rules that end with ".d.ts"
// but whose ".js"-generated files we want to concatenate. [deps] is for rules
// that end with ".js". [extra] is for files we want to concatenate but that
// are not generated.
var concatMap = {
    "mcrunner.js": {
        buildDeps: [ "rt/refs", "storage/refs", "mc/refs" ],
        deps: [],
        extra: [],
    },
    "noderunner.js": {
        buildDeps: [ "browser/browser", "rt/refs", "ast/refs", "libnode/refs", "noderunner/runner" ],
        deps: [ "build/api.js", "build/pkgshell.js" ],
        extra: [ "build/langs.js" ],
    },
    "runtime.js": {
        buildDeps: [ "rt/refs", "storage/refs", "libwinRT/refs", "libwab/refs",
            "libnode/refs", "libcordova/refs", "runner/refs" ],
        deps: [],
        extra: [],
    },
    "main.js": {
        buildDeps: [ "rt/refs", "ast/refs", "storage/refs", "libwinRT/refs",
            "libwab/refs", "libcordova/refs", "editor/refs" ],
        deps: [ "build/api.js", "build/pkgshell.js" ],
        extra: [ "build/langs.js" ],
    },
};

// Apparently our node scripts can't run without this line.
var nodePrelude = "var window = {};\n";

// The rules are generated from the map above, which distinguishes between build
// artifacts and file that were already there (so that the dependencies are
// registered properly).
Object.keys(concatMap).forEach(function (f) {
    // The rules this rule depends on.
    var deps = concatMap[f].buildDeps.map(function (x) { return x + ".d.ts" })
            .concat(concatMap[f].deps);
    // The files to be actually concatenated in the final output.
    var toConcat = concatMap[f].buildDeps.map(function(x) { return x + ".js" })
            .concat(concatMap[f].deps)
            .concat(concatMap[f].extra);
    file(f, deps, function () {
        console.log("[C]", f);
        var bufs = [];
        bufs.push(new Buffer(nodePrelude));
        toConcat.forEach(function (f) {
            bufs.push(fs.readFileSync(f));
        });
        fs.writeFileSync(f, Buffer.concat(bufs));
    });
});

// Our targets are the concatenated files, which are the final result of the
// compilation. We also re-run the CSS prefixes thingy everytime.
task('default', [ 'css-prefixes' ].concat(Object.keys(concatMap)), function () {
    console.log("\nBuild completed.");
});

task('clean', [], function () {
    // XXX do this in a single call? check out https://github.com/mde/utilities/blob/master/lib/file.js
    generated.forEach(function (f) { jake.rmRf(f); });
});

task('test', [ 'default' ], { async: true }, function () {
    jake.exec([ 'node nodeclient/client.js buildtest' ], {}, function() { complete(); });
});

task('run', [ 'default' ], { async: true }, function () {
    jake.exec(
        [ 'node noderunner 80 silent ' ],
        { printStdout: true, printStderr: true },
        function() { complete(); }
    );
});
